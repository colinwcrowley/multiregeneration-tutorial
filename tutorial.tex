\documentclass[12pt]{article}
\usepackage[margin=1.1in]{geometry}
\usepackage{enumerate,amsmath,amsthm,amssymb,amsfonts,mathtools}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{framed}

\newtheorem{theorem}{Theorem}[section]

\title{\large \bf
Multiregeneration Tutorial
}
\author{}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}                                                                                                      
    
\newcommand{\R}{\mathbb{R}}
\newcommand{\Div}{\text{Div}}
\newcommand{\Hom}{\text{Hom}}
\newcommand{\Jac}{\text{Jac}}
\newcommand{\Deg}{\text{Deg}}
\newcommand{\rk}{\text{rk}\ }
\newcommand{\coker}{\text{coker}\ }
\newcommand{\Princ}{\text{Princ}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\V}[1]{\mathbf{#1}}
\newcommand{\Spt}{\text{support}}
\begin{document}
\maketitle
\section{Getting Started}
Say that we are given the following $2$ polynomials
in $2$ variables. 
\begin{align*}
    f_1 &= (x-1)(y-3)\\
    f_2 &= (x-2)(y-4)\\
\end{align*}
% Our goal is to describe algorithmically all points in the set 

% \[
%     \mathcal{V}(f_1, f_2) = \{(z_1,z_2) \in \C^2 : f_1(z_1, z_2) = 
%     f_2(z_1, z_2) = 0\}
% \]
% which we call the \emph{zero locus} or the \emph{vanishing} of $f_1$ and 
% $f_2$. \\

\noindent To solve the system above, let's change into the folder 
``getting-started'', which contains the following three files.\\

\noindent \textbf{bertiniInput\_variables}


\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
    variable_group x,y; 
\end{verbatim}\vspace{-10pt} 
\end{leftbar}

\noindent \textbf{bertiniInput\_equations}


\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
    function f1,f2;
    f1 = (x-1)*(y-3);
    f2 = (x-2)*(y-4);
\end{verbatim}\vspace{-10pt} 
\end{leftbar}

\noindent \textbf{bertiniInput\_trackingOptions}
\emph{this file is empty}

\noindent \textbf{inputFile.py}

\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
    degrees = [[2], [2]]
    workingDirectory = "run"
\end{verbatim}\vspace{-10pt} 
\end{leftbar}

The first three files (those with the prefix ``bertiniInput'') are 
written in the C-like syntax used by the bertini software. The last 
file, ``inputFile.py'', contains the additional data that this 
program needs.

For the expert user there are many bertini options which can 
improve performance. These can be added 
to the file ``bertiniInput\_trackingOptions'' but we will ingnore them for now.
% Can we adjust the implementation so that if this is not specified it still works?

The variable ``degrees'' must be initialized to a list of lists, where 
the $j$'th element of the $i$'th list is the degree of the $i$'th 
function in the $j$th ``variable group.'' For this example there is only 
one variable group consisting of $x,y$, and each function has degree two 
in this variable group. Therefor we use the python syntax

\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
    degrees = [[2], [2]]
\end{verbatim}\vspace{-10pt} 
\end{leftbar}
to create a list of two lists, where the single element of the first 
list is the degree of $f_1$ and the single element of the second list is 
the degree of $f_2$.

The variable ``workingDirectory'' tell the program the name of the 
folder where it should write the output. If we run the program a second 
time, then a folder of that name will already exist, and it will be 
deleted before anything else happens.

To solve the system, we use python2 to run the ``multiregeneration.py'' 
script \emph{from the ``getting-started'' folder}. The multiregeneration 
script will look for input files in the directory from which it is run, 
so make sure that you are in the directory with the system you wish to 
solve. 


\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
python2 ../multiregeneration.py
\end{verbatim}\vspace{-10pt} 
\end{leftbar}

If all goes well python will print out ``Done.'' and there should be 
a new directory called ``run''. If there was an error, then the most 
likely cause is that there was an error in one of the input files.

The solutions will be contained in the folder 

\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
run/_completed_smooth_solutions/depth_1
\end{verbatim}\vspace{-10pt} 
\end{leftbar}

For this example, there are two files called 

\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
solution_tracking_depth_1_gens_1_1_dim_0_varGroup_0_regenLinear_1_pointId_326664877375_788310760051
solution_tracking_depth_1_gens_1_1_dim_0_varGroup_0_regenLinear_1_pointId_918720474422_183602510053 
\end{verbatim}\vspace{-10pt} 
\end{leftbar}
The two file contain approximate complex values for the two solutions of 
the initial system. For example the first file contains the following.


\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
    1.999999999999996e+00 -4.107825191113079e-15
    3.000000000000000e+00 0.000000000000000e+00
\end{verbatim}\vspace{-10pt} 
\end{leftbar}

\noindent The file can be read as
\begin{align*}
    x &= 1.999999999999996 \times 10^0 - (4.107825191113079 \times 
    10^{-15})i\\
    y &= 3.000000000000000 \times 10^0 + (0.0000000000000000 \times 
    10^{0})i\\
\end{align*}
which is aproximately the solution $x = 2, y = 3$.


\section{Multiple variable groups}
To motivate the notion of variable groups, we begin by stating the 
following formulation of B\'{e}zout's Theorem.

\begin{theorem}
Let $f_1, \ldots, f_N$ be polynomials with complex coefficients in $n$ 
variables, and let $d_1, \ldots, d_N$ denote their degrees. If 
$\mathcal{V}(f_1, \ldots, f_N)$ is finite, than its size is at most 
$d_1d_2 \ldots d_N$. 
\end{theorem}

For now we will assume that our system has finitely many solutions.
Therefore the degrees $d_1, \ldots, d_n$ give an upper bound on the size 
of the output. It is not hard to construct examples where the number of 
solutions is exactly this bound, so in the case of general equations of 
degrees $d_1, \ldots, d_n$ this worst case bound cannot be improved.

Here is a simple example to illustrate this bound.
\begin{align*}
    f_1 &= x^2 + xy + x - y\\
    f_2 &= y^2 + 4xy - 2y
\end{align*}
We can verify as in the previous section that this system has exactly 
$d_1d_2 = 4$ solutions.

Let us remove the $x^2$ and $y^2$ terms from the example above.
\begin{align*}
    f_1 &= xy + x - y\\
    f_2 &= 4xy - 2y
\end{align*}
The degrees $d_1$ and $d_2$ have not changed, so the B\'{e}zout bound 
still predicts four solutions. However, removing the square terms 
reduced the number of solutions to two. This is a consequence of the 
Multi-homogenius B\'{e}zout theorem, which we state below.

Say that for each $1 \leq i \leq k$ we have a group of variables 
$\mathbf{x}_i = (x_{i,1}, \ldots, x_{i,n_i})$, for a total of $n := n_1 
+ \ldots + n_k$ variables. Let $f(\mathbf{x}_1, \ldots, 
\mathbf{x}_k)$ denote a polynomail in all $n$ variables. We define the 
\emph{multidegree} of $f$ to be the integer vector $\Deg(f) = 
(\Deg_1(f), \ldots, \Deg_k(f))$ where $\Deg_i(f)$ is the degree of $f$ 
treating all variables except for $\mathbf{x}_i$ as constants.

\begin{theorem}
Let $f_1, \ldots, f_N$ be polynomials with complex coefficients in the 
   variables $\mathbf{x}_1, 
\ldots, \mathbf{x}_n$. Consider the formal expression $\prod_{s = 1}^N 
\sum_{i = 1}^{k} \Deg_i(f_s) \alpha_i$ in indeterminants $\alpha_1, 
\ldots, \alpha_k$, and let $B$ denote the coefficient of the monomial 
$\alpha_1\ldots \alpha_k$. If $\mathcal{V}(f_1, \ldots, f_N)$ is finite, 
than its size is at most $B$.
\end{theorem}

The number $B$ is called the \emph{multi-homogenius B\'{e}zout number}.

Returning to our example, let us define variable groups $\mathbf{x}_1 = 
(x), \mathbf{x}_2 = (y)$. Then $\Deg(f_1) = (1,1)$ and $\Deg(f_2) = 
(1,1)$. From the expression
\[
    (\alpha_1 + \alpha_2)(\alpha_1 + \alpha_2) = \alpha_1^2 + 
   2\alpha_1\alpha_2 + \alpha_2^2
\]
we see that $B = 2$. So if $\mathcal{V}(f_1, f_2)$ is finite, its size is 
at most two.

When solving a polynomial system, if there is a variable group structure 
that gives a low multi-homogenius B\'{e}zout number, then this 
gives us better garunties about the number of solutions we will find. 
Moreover, the program can take advantage of this extra structure to do 
less work.

For an example of how to use variable groups, change into the directory 
called ``multiple\_variable\_groups'', which contains the following 
files.\\

\noindent \textbf{bertiniInput\_variables}
\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
    variable_group x; 
    variable_group y; 
\end{verbatim}\vspace{-10pt} 
\end{leftbar}

\noindent \textbf{bertiniInput\_equations}
\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
    function f1,f2;
    f1 = x*y + x - y;
    f2 = 4*x*y - 2*y;
\end{verbatim}\vspace{-10pt} 
\end{leftbar}

\noindent \textbf{bertiniInput\_trackingOptions}
\emph{this file is empty}

\noindent \textbf{inputFile.py}
\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
    degrees = [[1,1], [1,1]]
    workingDirectory = "run"
\end{verbatim}\vspace{-10pt} 
\end{leftbar}

The only differences when using multiple variable groups are the 
declaration of multiple variable groups in ``bertiniInput\_variables'' 
and the entries of the ``degree'' variable, which now contains the 
multidegrees $Deg(f_1)$ and $Deg(f_2)$.

\noindent As before we run
\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
python2 ../multiregeneration.py
\end{verbatim}\vspace{-10pt} 
\end{leftbar}
\noindent and look for the solution files in 
\begin{leftbar}
\vspace{-10pt} 
\begin{verbatim}
run/_completed_smooth_solutions/depth_1
\end{verbatim}\vspace{-10pt} 
\end{leftbar}
\noindent where we find the two solutions.

\section{Projective variable groups}
\section{Nonsquare systems}




\end{document}
